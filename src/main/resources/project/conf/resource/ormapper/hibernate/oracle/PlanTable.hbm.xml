<?xml version="1.0"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN" "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<!--/*
 * Framework Generated Hibernate Config hbm Source
 * - PLAN_TABLE - 
 */-->
<hibernate-mapping>
	<class name="project.conf.resource.ormapper.dto.oracle.PlanTable" table="PLAN_TABLE" lazy="false">
		<meta attribute="class-description" inherit="false"></meta>

		<id column="ROWID" type="java.lang.String"/>

		<property name="accessPredicates" column="ACCESS_PREDICATES" type="java.lang.String" length="4000"/>
		<property name="bytes" column="BYTES" type="java.lang.Double"/>
		<property name="cardinality" column="CARDINALITY" type="java.lang.Double"/>
		<property name="cost" column="COST" type="java.lang.Double"/>
		<property name="cpuCost" column="CPU_COST" type="java.lang.Double"/>
		<property name="depth" column="DEPTH" type="java.lang.Double"/>
		<property name="distribution" column="DISTRIBUTION" type="java.lang.String" length="30"/>
		<property name="filterPredicates" column="FILTER_PREDICATES" type="java.lang.String" length="4000"/>
		<property name="id" column="ID" type="java.lang.Double"/>
		<property name="ioCost" column="IO_COST" type="java.lang.Double"/>
		<property name="objectAlias" column="OBJECT_ALIAS" type="java.lang.String" length="65"/>
		<property name="objectInstance" column="OBJECT_INSTANCE" type="java.lang.Double"/>
		<property name="objectName" column="OBJECT_NAME" type="java.lang.String" length="30"/>
		<property name="objectNode" column="OBJECT_NODE" type="java.lang.String" length="128"/>
		<property name="objectOwner" column="OBJECT_OWNER" type="java.lang.String" length="30"/>
		<property name="objectType" column="OBJECT_TYPE" type="java.lang.String" length="30"/>
		<property name="operation" column="OPERATION" type="java.lang.String" length="30"/>
		<property name="optimizer" column="OPTIMIZER" type="java.lang.String" length="255"/>
		<property name="options" column="OPTIONS" type="java.lang.String" length="255"/>
		<property name="other" column="OTHER" type="java.lang.String" length="0"/>
		<property name="otherTag" column="OTHER_TAG" type="java.lang.String" length="255"/>
		<property name="otherXml" column="OTHER_XML" type="java.lang.String"/>
		<property name="parentId" column="PARENT_ID" type="java.lang.Double"/>
		<property name="partitionId" column="PARTITION_ID" type="java.lang.Double"/>
		<property name="partitionStart" column="PARTITION_START" type="java.lang.String" length="255"/>
		<property name="partitionStop" column="PARTITION_STOP" type="java.lang.String" length="255"/>
		<property name="planId" column="PLAN_ID" type="java.lang.Double"/>
		<property name="position" column="POSITION" type="java.lang.Double"/>
		<property name="projection" column="PROJECTION" type="java.lang.String" length="4000"/>
		<property name="qblockName" column="QBLOCK_NAME" type="java.lang.String" length="30"/>
		<property name="remarks" column="REMARKS" type="java.lang.String" length="4000"/>
		<property name="searchColumns" column="SEARCH_COLUMNS" type="java.lang.Double"/>
		<property name="statementId" column="STATEMENT_ID" type="java.lang.String" length="30"/>
		<property name="tempSpace" column="TEMP_SPACE" type="java.lang.Double"/>
		<property name="time" column="TIME" type="java.lang.Double"/>
		<property name="timestamp" column="TIMESTAMP" type="java.util.Date"/>
	</class>

	<sql-query name="planTable.selectAll">
	<![CDATA[
		SELECT ACCESS_PREDICATES,
		       BYTES,
		       CARDINALITY,
		       COST,
		       CPU_COST,
		       DEPTH,
		       DISTRIBUTION,
		       FILTER_PREDICATES,
		       ID,
		       IO_COST,
		       OBJECT_ALIAS,
		       OBJECT_INSTANCE,
		       OBJECT_NAME,
		       OBJECT_NODE,
		       OBJECT_OWNER,
		       OBJECT_TYPE,
		       OPERATION,
		       OPTIMIZER,
		       OPTIONS,
		       OTHER,
		       OTHER_TAG,
		       OTHER_XML,
		       PARENT_ID,
		       PARTITION_ID,
		       PARTITION_START,
		       PARTITION_STOP,
		       PLAN_ID,
		       POSITION,
		       PROJECTION,
		       QBLOCK_NAME,
		       REMARKS,
		       SEARCH_COLUMNS,
		       STATEMENT_ID,
		       TEMP_SPACE,
		       TIME,
		       TO_CHAR(TIMESTAMP, 'yyyymmddhh24miss') AS TIMESTAMP
		  FROM PLAN_TABLE
		 WHERE 1 = 1
		 ${auto_fill}
		 ${frameworkGeneratedWhere}
		 ${frameworkGeneratedOrderBy}
		 FOR UPDATE
	]]>
	</sql-query>

	<sql-query name="planTable.insert">
	<![CDATA[
		INSERT INTO PLAN_TABLE (
		       ACCESS_PREDICATES,
		       BYTES,
		       CARDINALITY,
		       COST,
		       CPU_COST,
		       DEPTH,
		       DISTRIBUTION,
		       FILTER_PREDICATES,
		       ID,
		       IO_COST,
		       OBJECT_ALIAS,
		       OBJECT_INSTANCE,
		       OBJECT_NAME,
		       OBJECT_NODE,
		       OBJECT_OWNER,
		       OBJECT_TYPE,
		       OPERATION,
		       OPTIMIZER,
		       OPTIONS,
		       OTHER,
		       OTHER_TAG,
		       OTHER_XML,
		       PARENT_ID,
		       PARTITION_ID,
		       PARTITION_START,
		       PARTITION_STOP,
		       PLAN_ID,
		       POSITION,
		       PROJECTION,
		       QBLOCK_NAME,
		       REMARKS,
		       SEARCH_COLUMNS,
		       STATEMENT_ID,
		       TEMP_SPACE,
		       TIME,
		       TIMESTAMP
		       )
		VALUES (
		       ${ACCESS_PREDICATES},
		       ${BYTES},
		       ${CARDINALITY},
		       ${COST},
		       ${CPU_COST},
		       ${DEPTH},
		       ${DISTRIBUTION},
		       ${FILTER_PREDICATES},
		       ${ID},
		       ${IO_COST},
		       ${OBJECT_ALIAS},
		       ${OBJECT_INSTANCE},
		       ${OBJECT_NAME},
		       ${OBJECT_NODE},
		       ${OBJECT_OWNER},
		       ${OBJECT_TYPE},
		       ${OPERATION},
		       ${OPTIMIZER},
		       ${OPTIONS},
		       ${OTHER},
		       ${OTHER_TAG},
		       ${OTHER_XML},
		       ${PARENT_ID},
		       ${PARTITION_ID},
		       ${PARTITION_START},
		       ${PARTITION_STOP},
		       ${PLAN_ID},
		       ${POSITION},
		       ${PROJECTION},
		       ${QBLOCK_NAME},
		       ${REMARKS},
		       ${SEARCH_COLUMNS},
		       ${STATEMENT_ID},
		       ${TEMP_SPACE},
		       ${TIME},
		       ${TIMESTAMP}
		       )
	]]>
	</sql-query>

	<sql-query name="planTable.update">
	<![CDATA[
		UPDATE PLAN_TABLE
		   SET ACCESS_PREDICATES = ${ACCESS_PREDICATES},
		       BYTES = ${BYTES},
		       CARDINALITY = ${CARDINALITY},
		       COST = ${COST},
		       CPU_COST = ${CPU_COST},
		       DEPTH = ${DEPTH},
		       DISTRIBUTION = ${DISTRIBUTION},
		       FILTER_PREDICATES = ${FILTER_PREDICATES},
		       ID = ${ID},
		       IO_COST = ${IO_COST},
		       OBJECT_ALIAS = ${OBJECT_ALIAS},
		       OBJECT_INSTANCE = ${OBJECT_INSTANCE},
		       OBJECT_NAME = ${OBJECT_NAME},
		       OBJECT_NODE = ${OBJECT_NODE},
		       OBJECT_OWNER = ${OBJECT_OWNER},
		       OBJECT_TYPE = ${OBJECT_TYPE},
		       OPERATION = ${OPERATION},
		       OPTIMIZER = ${OPTIMIZER},
		       OPTIONS = ${OPTIONS},
		       OTHER = ${OTHER},
		       OTHER_TAG = ${OTHER_TAG},
		       OTHER_XML = ${OTHER_XML},
		       PARENT_ID = ${PARENT_ID},
		       PARTITION_ID = ${PARTITION_ID},
		       PARTITION_START = ${PARTITION_START},
		       PARTITION_STOP = ${PARTITION_STOP},
		       PLAN_ID = ${PLAN_ID},
		       POSITION = ${POSITION},
		       PROJECTION = ${PROJECTION},
		       QBLOCK_NAME = ${QBLOCK_NAME},
		       REMARKS = ${REMARKS},
		       SEARCH_COLUMNS = ${SEARCH_COLUMNS},
		       STATEMENT_ID = ${STATEMENT_ID},
		       TEMP_SPACE = ${TEMP_SPACE},
		       TIME = ${TIME},
		       TIMESTAMP = ${TIMESTAMP}
		 WHERE 1 = 1
		   ${frameworkGeneratedWhere}
	]]>
	</sql-query>

	<sql-query name="planTable.updateColumns">
	<![CDATA[
		UPDATE PLAN_TABLE
		   SET ${frameworkGeneratedColumnsToUpdate}
		 WHERE 1 = 1
		 ${frameworkGeneratedWhere}
	]]>
	</sql-query>

	<sql-query name="planTable.delete">
	<![CDATA[
		DELETE PLAN_TABLE
		 WHERE 1 = 1
		   ${frameworkGeneratedWhere}
	]]>
	</sql-query>
</hibernate-mapping>